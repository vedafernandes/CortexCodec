# -*- coding: utf-8 -*-
"""RoughCCPipeline

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uYcN5Jlj5bFPW1ueKu-_-IAiXImq3Sj4
"""

import numpy as np
import pandas as pd
import mne
import matplotlib.pyplot as plt

from mne.preprocessing import ICA
from mne.time_frequency import psd_array_welch

from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import (
    train_test_split,
    StratifiedKFold,
    GridSearchCV
)
from sklearn.metrics import (
    classification_report,
    ConfusionMatrixDisplay
)
from scipy.signal import butter, filtfilt, detrend
from scipy.signal import iirnotch
from sklearn.decomposition import FastICA
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis

from google.colab import drive
drive.mount("/content/drive")

filepath = "/content/drive/MyDrive/Files_CortexCodec/Copy of BrainFlow-RAW_sad_stimuli_2_7_0.csv"

df = pd.read_csv(
    filepath,
    comment='%',
    sep=None,
    engine='python'
)
print(df.head())

eeg = df.iloc[:, 1:17].values.T

eeg.shape
# should be # of columns vs # of data points

eeg *= 0.02235
# scaling to µV, math on whiteboard idk if its right lol

eeg -= np.mean(eeg, axis=1, keepdims=True)

print(np.min(eeg), "to", np.max(eeg))

for i in range(16):
    print(np.std(eeg[i]))

"""I used a butterworth bandpass filter bc it was familiar but I think it could be worthwhile to use the built in BrainFlow filter instead? If someone could test that out that would be cool: https://brainflow.readthedocs.io/en/stable/UserAPI.html

I think the DataFilter command works here but I'm lowk not sure how to use it :(
"""

# butterworth bandpass (see if you can figure out how this works on your own!)
# ref: https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.butter.html
# https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.filtfilt.html
low = 1
high = 60
fs = 125 # standard for daisy board

b, a = butter(4, [low/(fs/2), high/(fs/2)], btype='bandpass')

for i in range(16):
    eeg[i] = filtfilt(b, a, eeg[i])

# added a notch filter not sure if its super necessary but better safe than sorry
# https://www.mathworks.com/discovery/notch-filter.html
# https://www.mathworks.com/help/dsp/ref/iirnotch.html

b, a = iirnotch(60/(fs/2), 30)
filtfilt(b, a, eeg, axis=1)

t = np.arange(eeg.shape[1]) / fs

print(eeg.shape)
print(np.min(eeg), np.max(eeg))
print(np.std(eeg))
print(df.head())

# sanity checks to make sure nothing is broken

for i in range(16):
    plt.plot(t, eeg[i] + i)

plt.xlabel("Time (s)")
plt.ylabel("Amplitude (µV)")
plt.ylim(-4, 17)
plt.show()

# you can use this to zoom in on any channels you want from 0-16
# ex. plt.plot(t, eeg[0]) zooms in on channel 1
# you can also zoom in more on a single channel with like plt.plot(t, eeg[0, 0:10000]) or something probably
plt.plot(t, eeg[0])
plt.show()

eeg -= np.mean(eeg, axis=0, keepdims=True)

ica = FastICA(n_components=0.95, random_state=42, max_iter=1000)